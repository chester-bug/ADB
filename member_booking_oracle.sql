-- Oracle SQL script for Member and Booking modules only
-- Includes: 2 multi-table queries (each uses a view + output formatting),
-- 2 stored procedures, 2 triggers, 2 report procedures with nested cursors,
-- 1 sequence, 2 views, 2 indexes, and 2 exception types usage.

-- Enable DBMS_OUTPUT for report procedures
SET SERVEROUTPUT ON SIZE UNLIMITED

------------------------------------------------------------------------
-- Safe drops (idempotent)
------------------------------------------------------------------------
BEGIN EXECUTE IMMEDIATE 'DROP VIEW vw_booking_overview'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP VIEW vw_member_value'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TABLE booking_items CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TABLE bookings CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TABLE members CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP SEQUENCE seq_member_id'; EXCEPTION WHEN OTHERS THEN IF SQLCODE NOT IN (-2289, -04043) THEN RAISE; END IF; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP INDEX idx_bookings_member_start_time'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -1418 THEN RAISE; END IF; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP INDEX idx_booking_items_booking'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -1418 THEN RAISE; END IF; END;
/

------------------------------------------------------------------------
-- Core schema: members, bookings, booking_items
------------------------------------------------------------------------
CREATE TABLE members (
  member_id         NUMBER        PRIMARY KEY,
  email             VARCHAR2(255) NOT NULL,
  full_name         VARCHAR2(200) NOT NULL,
  phone             VARCHAR2(50),
  status            VARCHAR2(20)  DEFAULT 'ACTIVE' NOT NULL,
  created_at        DATE          DEFAULT SYSDATE   NOT NULL,
  updated_at        DATE,
  CONSTRAINT members_email_uk UNIQUE (email),
  CONSTRAINT members_status_ck CHECK (status IN ('ACTIVE','INACTIVE','SUSPENDED'))
);

CREATE TABLE bookings (
  booking_id        NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  member_id         NUMBER       NOT NULL,
  start_time        DATE         NOT NULL,
  end_time          DATE         NOT NULL,
  status            VARCHAR2(20) DEFAULT 'PENDING' NOT NULL,
  cancellation_reason VARCHAR2(4000),
  created_at        DATE         DEFAULT SYSDATE NOT NULL,
  updated_at        DATE,
  CONSTRAINT bookings_status_ck CHECK (status IN ('PENDING','CONFIRMED','CANCELLED','COMPLETED')),
  CONSTRAINT bookings_member_fk FOREIGN KEY (member_id) REFERENCES members(member_id)
);

CREATE TABLE booking_items (
  booking_item_id   NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  booking_id        NUMBER        NOT NULL,
  service_name      VARCHAR2(200) NOT NULL,
  quantity          NUMBER(10,2)  DEFAULT 1 NOT NULL,
  unit_price        NUMBER(12,2)  NOT NULL,
  discount_pct      NUMBER(5,2)   DEFAULT 0 NOT NULL,
  CONSTRAINT booking_items_booking_fk FOREIGN KEY (booking_id) REFERENCES bookings(booking_id),
  CONSTRAINT booking_items_qty_ck CHECK (quantity > 0),
  CONSTRAINT booking_items_price_ck CHECK (unit_price >= 0),
  CONSTRAINT booking_items_disc_ck CHECK (discount_pct BETWEEN 0 AND 100)
);

------------------------------------------------------------------------
-- Sequence for member IDs
------------------------------------------------------------------------
CREATE SEQUENCE seq_member_id START WITH 1000 INCREMENT BY 1 NOCACHE NOCYCLE;

------------------------------------------------------------------------
-- Indexes to optimize joins and validations
------------------------------------------------------------------------
CREATE INDEX idx_bookings_member_start_time ON bookings(member_id, start_time);
CREATE INDEX idx_booking_items_booking ON booking_items(booking_id);

------------------------------------------------------------------------
-- Views (to be used by the queries)
------------------------------------------------------------------------
-- View: Booking overview with totals and item counts
CREATE OR REPLACE VIEW vw_booking_overview AS
SELECT
  b.booking_id,
  b.member_id,
  b.start_time,
  b.end_time,
  b.status,
  m.full_name,
  m.email,
  NVL(SUM(bi.quantity * bi.unit_price * (1 - bi.discount_pct/100)), 0) AS booking_total,
  COUNT(bi.booking_item_id) AS item_count
FROM bookings b
JOIN members m ON m.member_id = b.member_id
LEFT JOIN booking_items bi ON bi.booking_id = b.booking_id
GROUP BY b.booking_id, b.member_id, b.start_time, b.end_time, b.status, m.full_name, m.email;

-- View: Member value summary with lifetime spend and segment
CREATE OR REPLACE VIEW vw_member_value AS
SELECT
  m.member_id,
  m.full_name,
  m.email,
  m.status,
  m.created_at,
  NVL(SUM(bi.quantity * bi.unit_price * (1 - bi.discount_pct/100)), 0) AS lifetime_spend,
  MAX(b.end_time) AS last_booking_at,
  COUNT(DISTINCT b.booking_id) AS total_bookings,
  CASE
    WHEN NVL(SUM(bi.quantity * bi.unit_price * (1 - bi.discount_pct/100)), 0) >= 5000 THEN 'Gold'
    WHEN NVL(SUM(bi.quantity * bi.unit_price * (1 - bi.discount_pct/100)), 0) >= 1000 THEN 'Silver'
    WHEN NVL(SUM(bi.quantity * bi.unit_price * (1 - bi.discount_pct/100)), 0) > 0 THEN 'Bronze'
    ELSE 'New'
  END AS value_segment
FROM members m
LEFT JOIN bookings b ON b.member_id = m.member_id
LEFT JOIN booking_items bi ON bi.booking_id = b.booking_id
GROUP BY m.member_id, m.full_name, m.email, m.status, m.created_at;

------------------------------------------------------------------------
-- Triggers enforcing business rules and policies
------------------------------------------------------------------------
-- Trigger 1: Validate bookings (active member, non-overlap, valid time window)
CREATE OR REPLACE TRIGGER trg_bookings_validate_member
  BEFORE INSERT OR UPDATE OF member_id, start_time, end_time, status ON bookings
  FOR EACH ROW
DECLARE
  v_member_status members.status%TYPE;
  v_overlap_count NUMBER;
BEGIN
  -- basic temporal validation
  IF :NEW.start_time >= :NEW.end_time THEN
    RAISE_APPLICATION_ERROR(-20001, 'Booking start_time must be before end_time.');
  END IF;

  -- member must exist and be ACTIVE to create/confirm a booking
  SELECT status INTO v_member_status FROM members WHERE member_id = :NEW.member_id;
  IF v_member_status <> 'ACTIVE' AND :NEW.status IN ('PENDING','CONFIRMED') THEN
    RAISE_APPLICATION_ERROR(-20001, 'Inactive/Suspended member cannot hold active bookings.');
  END IF;

  -- prevent overlapping bookings for same member when status is active-like
  IF :NEW.status IN ('PENDING','CONFIRMED') THEN
    SELECT COUNT(*) INTO v_overlap_count
    FROM bookings b
    WHERE b.member_id = :NEW.member_id
      AND b.status IN ('PENDING','CONFIRMED')
      AND (:NEW.start_time < b.end_time AND :NEW.end_time > b.start_time)
      AND ( :NEW.booking_id IS NULL OR b.booking_id <> :NEW.booking_id );

    IF v_overlap_count > 0 THEN
      RAISE_APPLICATION_ERROR(-20001, 'Overlapping booking for the same member is not allowed.');
    END IF;
  END IF;

  :NEW.updated_at := SYSDATE;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20006, 'Member does not exist for the booking.');
END;
/

-- Trigger 2: Upon member deactivation, auto-cancel all future active bookings
CREATE OR REPLACE TRIGGER trg_members_deactivation_cancel_future
  BEFORE UPDATE OF status ON members
  FOR EACH ROW
BEGIN
  :NEW.updated_at := SYSDATE;
  IF :NEW.status = 'INACTIVE' AND NVL(:OLD.status, 'ACTIVE') <> 'INACTIVE' THEN
    UPDATE bookings
    SET status = 'CANCELLED',
        cancellation_reason = 'Auto-cancel due to member deactivation on ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD'),
        updated_at = SYSDATE
    WHERE member_id = :NEW.member_id
      AND status IN ('PENDING','CONFIRMED')
      AND start_time > SYSDATE;
  END IF;
END;
/

------------------------------------------------------------------------
-- Stored Procedures (data manipulation and validation)
------------------------------------------------------------------------
-- Procedure 1: Upsert member (insert if new, otherwise update). Uses sequence.
CREATE OR REPLACE PROCEDURE sp_upsert_member(
  p_member_id   IN OUT members.member_id%TYPE,
  p_email       IN     members.email%TYPE,
  p_full_name   IN     members.full_name%TYPE,
  p_phone       IN     members.phone%TYPE,
  p_status      IN     members.status%TYPE DEFAULT 'ACTIVE'
) AS
  -- Map our business rule error for easier handling if bubbled from triggers
  e_business_rule EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_business_rule, -20001);
BEGIN
  IF p_member_id IS NULL THEN
    p_member_id := seq_member_id.NEXTVAL;
    INSERT INTO members(member_id, email, full_name, phone, status, created_at, updated_at)
    VALUES (p_member_id, p_email, p_full_name, p_phone, p_status, SYSDATE, SYSDATE);
  ELSE
    UPDATE members
    SET email = p_email,
        full_name = p_full_name,
        phone = p_phone,
        status = p_status,
        updated_at = SYSDATE
    WHERE member_id = p_member_id;

    IF SQL%ROWCOUNT = 0 THEN
      -- No row to update: treat as insert
      INSERT INTO members(member_id, email, full_name, phone, status, created_at, updated_at)
      VALUES (p_member_id, p_email, p_full_name, p_phone, p_status, SYSDATE, SYSDATE);
    END IF;
  END IF;
EXCEPTION
  WHEN DUP_VAL_ON_INDEX THEN
    RAISE_APPLICATION_ERROR(-20002, 'A member with the same email already exists.');
  WHEN e_business_rule THEN
    RAISE_APPLICATION_ERROR(-20001, 'Business rule violation while upserting member.');
END;
/

-- Procedure 2: Cancel booking with validations
CREATE OR REPLACE PROCEDURE sp_cancel_booking(
  p_booking_id IN bookings.booking_id%TYPE,
  p_reason     IN VARCHAR2
) AS
  v_status     bookings.status%TYPE;
  v_start_time bookings.start_time%TYPE;
BEGIN
  SELECT status, start_time INTO v_status, v_start_time
  FROM bookings
  WHERE booking_id = p_booking_id
  FOR UPDATE;

  IF v_status = 'CANCELLED' THEN
    RAISE_APPLICATION_ERROR(-20003, 'Booking is already cancelled.');
  ELSIF v_status = 'COMPLETED' THEN
    RAISE_APPLICATION_ERROR(-20003, 'Completed bookings cannot be cancelled.');
  ELSIF v_start_time <= SYSDATE THEN
    RAISE_APPLICATION_ERROR(-20003, 'Past/ongoing bookings cannot be cancelled.');
  END IF;

  UPDATE bookings
  SET status = 'CANCELLED',
      cancellation_reason = NVL(p_reason, 'Cancelled by user'),
      updated_at = SYSDATE
  WHERE booking_id = p_booking_id;

  IF SQL%ROWCOUNT = 0 THEN
    RAISE_APPLICATION_ERROR(-20004, 'Booking not found to cancel.');
  END IF;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20004, 'Booking not found.');
END;
/

------------------------------------------------------------------------
-- Report Procedures (nested cursors; summary/detail; on-demand via params)
------------------------------------------------------------------------
-- Report 1 (Detail, On-demand): Member activity with per-booking and per-item detail
CREATE OR REPLACE PROCEDURE sp_report_member_activity(
  p_start_date IN DATE,
  p_end_date   IN DATE
) AS
BEGIN
  DBMS_OUTPUT.PUT_LINE('Member Activity Report from ' || TO_CHAR(p_start_date, 'YYYY-MM-DD') || ' to ' || TO_CHAR(p_end_date, 'YYYY-MM-DD'));
  DBMS_OUTPUT.PUT_LINE('');

  FOR r_member IN (
    SELECT mv.member_id, mv.full_name, mv.status,
           COUNT(DISTINCT bo.booking_id) AS bookings_in_range,
           NVL(SUM(bo.booking_total),0) AS spend_in_range
    FROM vw_member_value mv
    LEFT JOIN vw_booking_overview bo ON bo.member_id = mv.member_id
      AND bo.start_time >= p_start_date AND bo.start_time < p_end_date
      AND bo.status IN ('CONFIRMED','COMPLETED')
    GROUP BY mv.member_id, mv.full_name, mv.status
    ORDER BY spend_in_range DESC, rpad(mv.full_name, 1)
  ) LOOP
    DBMS_OUTPUT.PUT_LINE('Member #' || r_member.member_id || ' - ' || r_member.full_name || ' (' || r_member.status || ')');
    DBMS_OUTPUT.PUT_LINE('  Bookings: ' || r_member.bookings_in_range || '  Spend: ' || TO_CHAR(r_member.spend_in_range, 'FM$999G999G999D00'));

    -- Nested cursor: bookings for this member
    FOR r_booking IN (
      SELECT bo.booking_id, bo.start_time, bo.end_time, bo.status, bo.booking_total
      FROM vw_booking_overview bo
      WHERE bo.member_id = r_member.member_id
        AND bo.start_time >= p_start_date AND bo.start_time < p_end_date
      ORDER BY bo.start_time
    ) LOOP
      DBMS_OUTPUT.PUT_LINE('    Booking #' || r_booking.booking_id || ' ' || TO_CHAR(r_booking.start_time,'YYYY-MM-DD HH24:MI') || ' - ' || TO_CHAR(r_booking.end_time,'YYYY-MM-DD HH24:MI') || '  Status: ' || r_booking.status || '  Total: ' || TO_CHAR(r_booking.booking_total, 'FM$999G999G999D00'));

      -- Nested inner cursor: items for this booking
      FOR r_item IN (
        SELECT service_name, quantity, unit_price, discount_pct,
               (quantity * unit_price * (1 - discount_pct/100)) AS line_total
        FROM booking_items
        WHERE booking_id = r_booking.booking_id
        ORDER BY service_name
      ) LOOP
        DBMS_OUTPUT.PUT_LINE('      - ' || r_item.service_name || ': qty=' || TO_CHAR(r_item.quantity,'FM999D99') ||
                             ', price=' || TO_CHAR(r_item.unit_price, 'FM$999G999D00') ||
                             ', disc=' || TO_CHAR(r_item.discount_pct,'FM999D99') || '%  line=' || TO_CHAR(r_item.line_total, 'FM$999G999D00'));
      END LOOP; -- items
    END LOOP; -- bookings

    DBMS_OUTPUT.PUT_LINE('');
  END LOOP; -- members
END;
/

-- Report 2 (Summary, On-demand): Monthly revenue with top members per month
CREATE OR REPLACE PROCEDURE sp_report_monthly_revenue(
  p_year IN NUMBER DEFAULT EXTRACT(YEAR FROM SYSDATE)
) AS
  v_month_start DATE;
BEGIN
  DBMS_OUTPUT.PUT_LINE('Monthly Revenue Report for year ' || p_year);
  DBMS_OUTPUT.PUT_LINE('');

  FOR r_month IN (
    SELECT ADD_MONTHS(TRUNC(TO_DATE('01-01-'||p_year, 'DD-MM-YYYY'), 'MM'), LEVEL - 1) AS month_start
    FROM dual CONNECT BY LEVEL <= 12
  ) LOOP
    v_month_start := r_month.month_start;

    -- Monthly summary row
    DECLARE
      v_num_bookings NUMBER;
      v_revenue      NUMBER;
      v_avg_value    NUMBER;
    BEGIN
      SELECT COUNT(*), NVL(SUM(bo.booking_total),0), NVL(AVG(bo.booking_total),0)
      INTO v_num_bookings, v_revenue, v_avg_value
      FROM vw_booking_overview bo
      WHERE bo.status IN ('CONFIRMED','COMPLETED')
        AND bo.start_time >= v_month_start
        AND bo.start_time < ADD_MONTHS(v_month_start, 1);

      DBMS_OUTPUT.PUT_LINE(TO_CHAR(v_month_start, 'YYYY-Mon') || '  Bookings=' || v_num_bookings || '  Revenue=' || TO_CHAR(v_revenue, 'FM$999G999G999D00') || '  Avg=' || TO_CHAR(v_avg_value, 'FM$999G999D00'));

      -- Nested cursor: Top 5 members by revenue this month
      FOR r_top IN (
        SELECT mv.member_id, mv.full_name, mv.value_segment,
               NVL(SUM(bo.booking_total),0) AS revenue
        FROM vw_booking_overview bo
        JOIN vw_member_value mv ON mv.member_id = bo.member_id
        WHERE bo.status IN ('CONFIRMED','COMPLETED')
          AND bo.start_time >= v_month_start
          AND bo.start_time < ADD_MONTHS(v_month_start, 1)
        GROUP BY mv.member_id, mv.full_name, mv.value_segment
        ORDER BY revenue DESC
        FETCH FIRST 5 ROWS ONLY
      ) LOOP
        DBMS_OUTPUT.PUT_LINE('    #' || r_top.member_id || ' ' || r_top.full_name || ' (' || r_top.value_segment || '): ' || TO_CHAR(r_top.revenue, 'FM$999G999D00'));
      END LOOP; -- top members

      DBMS_OUTPUT.PUT_LINE('');
    END;
  END LOOP; -- months
END;
/

------------------------------------------------------------------------
-- Two Multi-table Queries (with views + output formatting)
------------------------------------------------------------------------
-- Query 1 (Strategic): Monthly revenue by member value segment
PROMPT === Strategic Query: Monthly revenue and bookings by member value segment ===
SET LINESIZE 200
SET PAGESIZE 200
COLUMN month LABEL 'Month' FORMAT A7
COLUMN value_segment LABEL 'Segment' FORMAT A10
COLUMN num_bookings LABEL 'Bookings' FORMAT 999G999
COLUMN revenue LABEL 'Revenue' FORMAT $999G999G990D00
COLUMN avg_booking_value LABEL 'Avg Value' FORMAT $999G999D00

SELECT
  TO_CHAR(bo.start_time, 'YYYY-MM') AS month,
  mv.value_segment,
  COUNT(DISTINCT bo.booking_id) AS num_bookings,
  SUM(bo.booking_total) AS revenue,
  AVG(bo.booking_total) AS avg_booking_value
FROM vw_booking_overview bo
JOIN vw_member_value mv ON mv.member_id = bo.member_id
WHERE bo.status IN ('CONFIRMED','COMPLETED')
  AND bo.start_time >= ADD_MONTHS(TRUNC(SYSDATE, 'YEAR'), -11)
  AND bo.start_time < ADD_MONTHS(TRUNC(SYSDATE, 'MONTH'), 1)
GROUP BY TO_CHAR(bo.start_time, 'YYYY-MM'), mv.value_segment
ORDER BY month, value_segment;

-- Query 2 (Operational/Tactical): Next-14-days capacity and revenue by day with segment counts
PROMPT === Operational Query: Next 14 days bookings, items, revenue, and member segments ===
SET LINESIZE 200
SET PAGESIZE 200
COLUMN booking_date LABEL 'Date' FORMAT A12
COLUMN num_bookings LABEL 'Bookings' FORMAT 999G999
COLUMN total_items LABEL 'Items' FORMAT 999G999
COLUMN revenue LABEL 'Revenue' FORMAT $999G999G990D00
COLUMN avg_value LABEL 'Avg Value' FORMAT $999G999D00
COLUMN gold_members LABEL 'Gold' FORMAT 999G999
COLUMN silver_members LABEL 'Silver' FORMAT 999G999
COLUMN bronze_members LABEL 'Bronze' FORMAT 999G999
COLUMN new_members LABEL 'New' FORMAT 999G999

SELECT
  TO_CHAR(TRUNC(bo.start_time), 'YYYY-MM-DD') AS booking_date,
  COUNT(*) AS num_bookings,
  SUM(bo.item_count) AS total_items,
  SUM(bo.booking_total) AS revenue,
  AVG(bo.booking_total) AS avg_value,
  COUNT(DISTINCT CASE WHEN mv.value_segment = 'Gold' THEN bo.member_id END) AS gold_members,
  COUNT(DISTINCT CASE WHEN mv.value_segment = 'Silver' THEN bo.member_id END) AS silver_members,
  COUNT(DISTINCT CASE WHEN mv.value_segment = 'Bronze' THEN bo.member_id END) AS bronze_members,
  COUNT(DISTINCT CASE WHEN mv.value_segment = 'New' THEN bo.member_id END) AS new_members
FROM vw_booking_overview bo
JOIN vw_member_value mv ON mv.member_id = bo.member_id
WHERE bo.start_time >= TRUNC(SYSDATE)
  AND bo.start_time < TRUNC(SYSDATE) + 14
  AND bo.status IN ('PENDING','CONFIRMED')
GROUP BY TRUNC(bo.start_time)
ORDER BY booking_date;

------------------------------------------------------------------------
-- Usage examples (uncomment to test in SQL*Plus or SQLcl)
------------------------------------------------------------------------
-- INSERT SAMPLE DATA (optional)
-- INSERT INTO members(member_id, email, full_name, phone, status, created_at, updated_at)
-- VALUES (seq_member_id.NEXTVAL, 'alice@example.com', 'Alice Lee', '111-111', 'ACTIVE', SYSDATE, SYSDATE);
-- DECLARE v_id NUMBER; BEGIN v_id := NULL; sp_upsert_member(v_id, 'bob@example.com', 'Bob Ray', '222-222', 'ACTIVE'); END; /
-- INSERT INTO bookings(member_id, start_time, end_time, status) SELECT member_id, SYSDATE+1, SYSDATE+1.5/24, 'CONFIRMED' FROM members WHERE ROWNUM=1; 
-- INSERT INTO booking_items(booking_id, service_name, quantity, unit_price, discount_pct) VALUES (1, 'Yoga Class', 1, 50, 0);
-- COMMIT;

-- CALL REPORTS
-- EXEC sp_report_member_activity(TRUNC(SYSDATE)-30, TRUNC(SYSDATE)+1);
-- EXEC sp_report_monthly_revenue(EXTRACT(YEAR FROM SYSDATE));

